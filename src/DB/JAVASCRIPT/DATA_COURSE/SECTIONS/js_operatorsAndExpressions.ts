export const js_operatorsAndExpressions_1 = {
  id: "js_operators_1",
  title: "Арифметические операторы",
  content: `
## Что такое арифметические операторы

Арифметические операторы — это символы, с помощью которых можно выполнять математические действия над числами. Такие действия как сложение, вычитание, умножение и деление называются арифметическими операциями, а числа, с которыми мы работаем, называются операндами.

**Оператор** — это знак, который указывает, что нужно сделать с операндами.  
**Операнд** — это значение (обычно число), над которым выполняется операция.

---

### Основные арифметические операторы в JavaScript

| Оператор | Название             | Пример   | Результат |
| -------- | -------------------- | -------- | --------- |
| +        | Сложение             | 5 + 2     | 7         |
| -        | Вычитание            | 5 - 2     | 3         |
| *        | Умножение            | 5 * 2     | 10        |
| /        | Деление              | 10 / 2    | 5         |
| %        | Остаток деления      | 7 % 3     | 1         |
| **       | Возведение в степень | 2 ** 3    | 8         |

---

### Примеры:

\`\`\`js
let a = 10;
let b = 3;

console.log(a + b); // 13
console.log(a - b); // 7
console.log(a * b); // 30
console.log(a / b); // 3.333...
console.log(a % b); // 1
console.log(2 ** 4); // 16
\`\`\`

---

### Важные замечания

#### Деление на ноль (/ 0) даёт специальное значение Infinity или -Infinity.

#### Остаток может быть полезен, например, для определения чётных и нечётных чисел:

\`\`\`js
let number = 7;
let isEven = number % 2 === 0; // false — число нечётное
\`\`\`

---

### Подводные камни при работе с арифметическими операторами

#### 1. Сложение строк и чисел (+ — перегруженный оператор)

В JavaScript оператор + может выполнять не только сложение чисел, но и конкатенацию строк. Это может привести к неожиданным результатам.

\`\`\`js
console.log(2 + 3);       // 5 — обычное сложение чисел
console.log("2" + 3);     // "23" — строка, потому что "2" — строка
console.log(2 + "3");     // "23" — тоже строка
\`\`\`

> **Важно:** если хотя бы один из операндов — строка, + превращает второй операнд в строку и "склеивает" их.

#### 2. Другие операторы (-, *, /, %) работают только с числами

Если попытаться вычитать строку, JavaScript попытается привести строку к числу:

\`\`\`js
console.log("10" - 5);  // 5 — строка "10" преобразована в число
console.log("10" * "2"); // 20 — обе строки преобразованы в числа
console.log("abc" - 1); // NaN — строка "abc" не может быть преобразована
\`\`\`

#### 3. Деление на ноль

\`\`\`js
console.log(10 / 0);   // Infinity
console.log(-10 / 0);  // -Infinity
console.log(0 / 0);    // NaN
\`\`\`

Деление на ноль не вызывает ошибку, но может повлиять на логику.  
**Infinity** — специальное значение, а не ошибка.  
**0 / 0** не имеет смысла, поэтому даёт **NaN**.

#### 4. Плавающая точка и погрешности

JavaScript использует стандарт IEEE 754 для работы с числами с плавающей точкой, из-за чего возможны погрешности при вычислениях:

\`\`\`js
console.log(0.1 + 0.2); // 0.30000000000000004 — неожиданно!
console.log(0.3 === 0.1 + 0.2); // false
\`\`\`

Почему так? В двоичной системе не все десятичные дроби можно точно представить. Это как если бы ты пытался точно выразить 1/3 десятичной дробью — получится бесконечная 0.333...

**Решение:** округлять значения, если это важно.

\`\`\`js
let sum = 0.1 + 0.2;
console.log(Number(sum.toFixed(1))); // 0.3
\`\`\`

Метод \`toFixed(n)\` используется, чтобы округлить число до \`n\` знаков после запятой.

#### 5. Преобразование типов: null, undefined, true, false

Иногда к числам прибавляют значения других типов:

\`\`\`js
console.log(5 + null);      // 5 — null преобразуется в 0
console.log(5 + undefined); // NaN — undefined не преобразуется
console.log(5 + true);      // 6 — true → 1
console.log(5 + false);     // 5 — false → 0
\`\`\`

#### 6. Унарный + и - — приведение к числу

\`\`\`js
console.log(+"10");   // 10 — строка "10" превращается в число
console.log(+"abc");  // NaN — невалидная строка
console.log(+true);   // 1
console.log(+false);  // 0
console.log(-"7");    // -7
\`\`\`

**Унарный +** — это простой способ преобразовать значение в число.

#### 7. NaN — заразное значение

Если в выражении участвует NaN, результат тоже NaN:

\`\`\`js
let badValue = "abc" - 1; // NaN
console.log(badValue + 5); // NaN
console.log(badValue * 2); // NaN
\`\`\`

#### 8. Остаток (%) с отрицательными числами

\`\`\`js
console.log(10 % 3);   // 1
console.log(-10 % 3);  // -1
console.log(10 % -3);  // 1
console.log(-10 % -3); // -1
\`\`\`

Знак остатка всегда совпадает со знаком делимого (первого числа).

### Вывод

Арифметические операторы — это основа математических вычислений в JavaScript. Важно понимать, как они работают, какие бывают исключения и как обрабатываются разные типы значений.
`,

  codeExampleJS: `
let a = 10;
let b = 3;

console.log(a + b); // 13
console.log(a - b); // 7
console.log(a * b); // 30
console.log(a / b); // 3.333...
console.log(a % b); // 1
console.log(2 ** 4); // 16
  `,

  resources: [
    "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators",
    "https://learn.javascript.ru/operators",
  ],
};
export const js_operatorsAndExpressions_2 = {
  id: "js_operators_2",
  title: "Инкремент и декремент",
  content: `
## Что такое инкремент и декремент

**Инкремент** — это оператор, который увеличивает число на 1.  
**Декремент** — оператор, который уменьшает число на 1.

Эти операторы называют **унарными** — они работают только с одним операндом (значением).

---

### Основные операторы

| Оператор | Название    | Описание                    |
| -------- | ----------- | --------------------------- |
| ++       | Инкремент   | Увеличивает значение на 1   |
| --       | Декремент   | Уменьшает значение на 1     |

Пример использования:

\`\`\`js
let x = 5;

x++; // x становится 6
x--; // x снова 5
\`\`\`

---

### Префиксная и постфиксная форма

Оба оператора (\`++\` и \`--\`) можно ставить как **до**, так и **после** переменной. От этого зависит порядок выполнения и возвращаемое значение.

| Вид      | Пример | Поведение                                            |
| -------- | ------ | ---------------------------------------------------- |
| Префикс  | ++x    | Сначала увеличивает (или уменьшает), потом возвращает новое значение |
| Постфикс | x++    | Сначала возвращает старое значение, потом увеличивает (или уменьшает) |

---

#### Сравнение на примере

Рассмотрим работу операторов:

\`\`\`js
let a = 5;

let b = a++; // b = 5, a = 6
let c = ++a; // c = 7, a = 7
\`\`\`

- \`a++\` — сначала \`b\` получает текущее значение \`a\` (5), потом \`a\` увеличивается до 6.
- \`++a\` — сначала \`a\` увеличивается с 6 до 7, потом новое значение (7) присваивается \`c\`.

---

### Важные замечания и подводные камни

- Операторы \`++\` и \`--\` — это **короткая запись** для увеличения/уменьшения значения на 1.  
  То есть \`x++\` эквивалентно \`x = x + 1\`, а \`x--\` — \`x = x - 1\`.
- В "простом" использовании (\`x++\`, \`x--\`) — форма (префиксная или постфиксная) обычно не важна.
- Разница между \`x++\` и \`++x\` проявляется, если результат инкремента/декремента участвует в выражении (например, при присваивании другой переменной или в сложных вычислениях).
- Оба оператора работают только с переменными (нельзя применить к числовым литералам).

---

### Вывод

Операторы **инкремент** (\`++\`) и **декремент** (\`--\`) — это удобные сокращения для изменения значения на 1.  
Используйте их свободно для счётчиков, перебора циклов, простых арифметических операций.

> Важно: всегда учитывайте разницу между префиксной (\`++x\`, \`--x\`) и постфиксной (\`x++\`, \`x--\`) формой, если оператор участвует в выражении.
  `,
  codeExampleJS: `
let a = 5;

let b = a++; // b = 5, a = 6
let c = ++a; // c = 7, a = 7

let x = 10;
x++;
console.log(x); // 11

x--;
console.log(x); // 10
  `,
  resources: [
    "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Increment",
    "https://learn.javascript.ru/increment",
  ],
};
export const js_operatorsAndExpressions_3 = {
  id: "js_operators_3",
  title: "Операторы сравнения",
  content: `
## Что такое операторы сравнения

Операторы сравнения позволяют сравнивать значения между собой.  
Результатом такого сравнения всегда будет булевое значение — \`true\` (истина) или \`false\` (ложь).

\`\`\`js
console.log(5 > 3); // true
console.log(5 < 3); // false
\`\`\`

---

### Основные операторы сравнения в JavaScript

| Оператор | Название                    | Пример      | Результат |
| -------- | --------------------------- | ----------- | --------- |
| ==       | Равно (нестрогое сравнение) | 5 == "5"    | true      |
| !=       | Не равно (нестрогое)        | 5 != "5"    | false     |
| ===      | Строгое равно               | 5 === "5"   | false     |
| !==      | Строго не равно             | 5 !== "5"   | true      |
| >        | Больше                      | 7 > 3       | true      |
| <        | Меньше                      | 7 < 3       | false     |
| >=       | Больше или равно            | 5 >= 5      | true      |
| <=       | Меньше или равно            | 3 <= 2      | false     |

---

### Строгое и нестрогое сравнение

#### \`==\` и \`!=\` — нестрогое сравнение

При использовании \`==\` и \`!=\` JavaScript пытается привести типы данных к одному.  
Это может приводить к неожиданным результатам.

\`\`\`js
console.log(5 == "5");             // true — строка "5" преобразована в число
console.log(null == undefined);    // true — оба считаются "пустыми"
console.log(false == 0);           // true — false преобразован в 0
\`\`\`

#### \`===\` и \`!==\` — строгое сравнение

Типы не приводятся, сравниваются и значения, и типы.

\`\`\`js
console.log(5 === "5");            // false — число и строка
console.log(null === undefined);   // false — разные типы
console.log(false === 0);          // false — boolean и number
\`\`\`

> **Вывод:** почти всегда лучше использовать \`===\` и \`!==\`, чтобы избежать ошибок.

---

### Сравнение строк

Когда ты сравниваешь строки, JavaScript сравнивает их по символам — слева направо, один за другим.  
У каждого символа есть номер (код) в специальной таблице под названием Unicode.

Проще говоря: у каждой буквы (или символа) есть своё числовое значение, и JavaScript сравнивает именно эти значения.

\`\`\`js
console.log("apple" < "banana"); // true
\`\`\`

**Почему?**  
Сначала сравниваются первые символы: "a" и "b".  
У "a" код меньше, чем у "b", значит вся строка "apple" меньше строки "banana".

\`\`\`js
console.log("cat" > "car"); // true
\`\`\`

Первые две буквы одинаковые: "c" и "a" — совпадают.  
Третий символ: "t" и "r".  
У "t" код больше, чем у "r", поэтому "cat" больше, чем "car".

---

### Регистр (заглавные и строчные)

Важно знать: заглавные и строчные буквы — разные символы.  
И заглавные буквы считаются меньше, чем строчные:

\`\`\`js
console.log("Zoo" < "apple"); // true
\`\`\`

**Почему?**  
"Z" — заглавная буква, её код меньше, чем у строчной "a".  
Поэтому вся строка "Zoo" считается меньше, чем "apple".

---

### Проверка кодов символов

Ты можешь сам посмотреть числовой код любого символа:

\`\`\`js
console.log("A".charCodeAt(0)); // 65
console.log("a".charCodeAt(0)); // 97
\`\`\`

Значит, "A" < "a", потому что 65 < 97.  
Или просто воспользуйся готовыми таблицами, например: [Таблица Unicode](https://symbl.cc/ru/unicode-table/)

---

### Необычные случаи

**null и undefined:**

\`\`\`js
console.log(null == undefined);  // true
console.log(null === undefined); // false
console.log(null > 0);           // false
console.log(null == 0);          // false
console.log(null >= 0);          // true — особенность языка
\`\`\`

Это один из "странных" случаев в JavaScript.  
Лучше избегать сравнения \`null\` и \`undefined\` с числами напрямую.

**NaN — не сравнивается даже с собой**

\`\`\`js
console.log(NaN == NaN);  // false
console.log(NaN === NaN); // false

// Чтобы проверить, является ли значение NaN, используют специальную функцию:
console.log(Number.isNaN(NaN)); // true
\`\`\`

---

### Как происходит сравнение разных типов

JavaScript автоматически приводит типы при нестрогом сравнении:

\`\`\`js
console.log("5" == 5);     // true
console.log(false == 0);   // true
console.log(true == 1);    // true
console.log("" == 0);      // true
\`\`\`

**Сравнение строк с числами:**

\`\`\`js
console.log("5" > 3); // true — "5" преобразуется в число
console.log("abc" > 3); // false — "abc" не число → NaN → false
\`\`\`

---

### Сравнение boolean с числами и строками

JavaScript позволяет сравнивать булевы значения (\`true\`, \`false\`) с числами и строками:

\`\`\`js
console.log(true == 1);     // true
console.log(false == 0);    // true
console.log(true === 1);    // false — разные типы
console.log(false === 0);   // false
\`\`\`

При нестрогом сравнении (\`==\`) true становится 1, false — 0.  
При строгом (\`===\`) сравниваются и значения, и типы — поэтому false === 0 → false.

---

### Как работает преобразование типов в \`==\`

Когда ты пишешь \`a == b\`, и \`a\` и \`b\` разных типов, JavaScript делает преобразование. Например:

\`\`\`js
console.log("0" == 0);        // true — строка "0" → число 0
console.log("" == 0);         // true — пустая строка → 0
console.log(false == "0");    // true — false → 0, "0" → 0
\`\`\`

Это делает \`==\` опасным: ты можешь получить true там, где логика подсказывает false.
  `,
  codeExampleJS: `
console.log(5 == "5"); // true
console.log(5 === "5"); // false
console.log("apple" < "banana"); // true
console.log("Zoo" < "apple"); // true
console.log(null == undefined); // true
console.log(NaN == NaN); // false
console.log(Number.isNaN(NaN)); // true
console.log("0" == 0); // true
console.log(false == "0"); // true
  `,
  resources: [
    "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Comparison_Operators",
    "https://learn.javascript.ru/comparison",
    "https://symbl.cc/ru/unicode-table/",
  ],
};
export const js_operatorsAndExpressions_4 = {
  id: "js_operators_4",
  title: "Логические операторы",
  content: `
## Что такое логические операторы

Логические операторы позволяют принимать решения в зависимости от условий.  
Они работают с логическими значениями — \`true\` и \`false\`, но часто используются и с другими типами, особенно в JavaScript.

---

### \`||\` — Логическое ИЛИ

Оператор \`||\` возвращает первое истинное (truthy) значение, если оно есть.  
Если оба значения — ложные (falsy), возвращается последнее.

\`\`\`js
console.log(true || false);   // true
console.log(false || true);   // true
console.log(false || false);  // false
\`\`\`

В JavaScript оператор \`||\` используется также для подстановки значения по умолчанию:

\`\`\`js
let name = userInput || "Гость";
\`\`\`

Если \`userInput\` пустой ("", null, undefined, 0, false), то будет взято значение "Гость".

---

### \`&&\` — Логическое И

Оператор \`&&\` возвращает первое ложное (falsy) значение.  
Если все значения истинные, возвращается последнее.

\`\`\`js
console.log(true && true);     // true
console.log(true && false);    // false
console.log(false && true);    // false
console.log(false && false);   // false
\`\`\`

Пример применения в условии:

\`\`\`js
let isLoggedIn = true;
let isAdmin = true;

if (isLoggedIn && isAdmin) {
  console.log("Добро пожаловать, администратор!");
}
\`\`\`

---

### \`!\` — Логическое НЕ

Оператор \`!\` инвертирует логическое значение: превращает \`true\` в \`false\`, и наоборот.

\`\`\`js
console.log(!true);  // false
console.log(!false); // true
\`\`\`

---

### \`??\` — Оператор нулевого слияния

Похож на \`||\`, но проверяет только \`null\` и \`undefined\`, не трогая 0, пустую строку и false.

\`\`\`js
let userName = null;
console.log(userName ?? "Гость"); // "Гость"

let count = 0;
console.log(count ?? 10); // 0 — потому что 0 не является null или undefined
\`\`\`

Это делает \`??\` более предсказуемым, чем \`||\`, в ситуациях, где 0 и "" являются допустимыми значениями.

---

### \`=\` — Логическое присваивание

Оператор \`=\` просто присваивает значение переменной.

\`\`\`js
let x;
x = 5;           // теперь x равен 5

let message = "";
message = "Привет!";
console.log(message); // "Привет!"
\`\`\`

---

### \`||=\` — Логическое присваивание по ИЛИ

\`\`\`js
x ||= y
\`\`\`

Работает как:  
\`x = x || y\`

**Что это значит?**  
Если x — ложное значение (false, 0, "", null, undefined, NaN), то x получает значение y.

\`\`\`js
let message = "";
message ||= "Привет!";
console.log(message); // "Привет!"
\`\`\`

Почему? Потому что "" — это ложное значение. Значит, сработает подстановка.

\`\`\`js
let message = "Привет";
message ||= "Друг";
console.log(message); // "Привет"
\`\`\`

Здесь message уже имеет значение, которое не "ложное" — поэтому оно не изменяется.

---

### \`&&=\` — Логическое присваивание И

\`\`\`js
a &&= b; // То же самое, что: a = a && b;
\`\`\`

**Что это значит?**  
Если x — истинное значение, то оно заменяется на y.  
Если x — ложное, то оно остаётся таким, как есть.

\`\`\`js
let status = true;
status &&= "online";
console.log(status); // "online"

let status = false;
status &&= "online";
console.log(status); // false
\`\`\`

Значение true — истинное, значит status становится "online".  
Значение false — ложное, присваивание не происходит.

---

### \`??=\` — Нулевое присваивание

Сокращение записи:

\`\`\`js
a ??= b; // То же самое, что: a = (a ?? b);
\`\`\`

Присваивает b, только если a === null или a === undefined.

\`\`\`js
let user = null;
user ??= "Аноним";
console.log(user); // "Аноним"

let user = "";
user ??= "Аноним";
console.log(user); // "" — пустая строка сохраняется
\`\`\`

Потому что "" — не null и не undefined, значит, подставлять не нужно.

---

### Сравнение: \`||\` vs \`??\`

\`\`\`js
let a = 0;
console.log(a || 5);  // 5 — 0 считается "ложным"
console.log(a ?? 5);  // 0 — сохраняется, т.к. это не null/undefined
\`\`\`

---

### Комплексный пример:

\`\`\`js
let a = "";
let b = "текст";
let c = null;

a ||= "по умолчанию"; // сработает, потому что "" — ложное
b &&= "новое";        // сработает, потому что "текст" — истинное
c ??= "аноним";       // сработает, потому что c — null

console.log(a); // "по умолчанию"
console.log(b); // "новое"
console.log(c); // "аноним"
\`\`\`
  `,
  codeExampleJS: `
console.log(true || false); // true
console.log(false && true); // false
console.log(!false); // true

let name = undefined;
let userName = name || "Гость";
console.log(userName); // "Гость"

let userCount = 0;
console.log(userCount || 5); // 5
console.log(userCount ?? 5); // 0

let user = null;
user ??= "Аноним";
console.log(user); // "Аноним"

let status = false;
status &&= "online";
console.log(status); // false

let msg = "";
msg ||= "Привет!";
console.log(msg); // "Привет!"
  `,
  resources: [
    "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_Operators",
    "https://learn.javascript.ru/logical-operators",
  ],
};
export const js_operatorsAndExpressions_5 = {
  id: "js_operators_5",
  title: "Приоритет операций",
  content: `
## Что такое приоритет операций?

Вспомни, как бы ты выполнял задание на уроке математики:

\`\`\`js
2 + 3 * 4
\`\`\`

Некоторые подумают: "Сначала 2 + 3, потом умножим на 4".  
Но в математике (и в JavaScript) умножение важнее сложения, и делается первым.

Это и есть **приоритет операций**.

**Приоритет операций** — это правило, которое определяет, в каком порядке JavaScript будет выполнять операции в выражении, где есть несколько операторов (например, +, *, =, && и т.д.).

Если бы приоритета не было, JavaScript не знал бы, что делать первым и получал бы неправильные ответы.

---

### Таблица приоритетов (упрощённо)

| Оператор      | Пример      | Приоритет | Описание                      |
| ------------- | ----------- | --------- | ----------------------------- |
| ()            | (2 + 3)     | 20        | Скобки — всегда первые        |
| *, /, %       | 3 * 4       | 15        | Умножение, деление, остаток   |
| +, -          | 2 + 3       | 14        | Сложение, вычитание           |
| =             | x = 5       | 3         | Присваивание значения         |

*Чем выше число, тем выше приоритет. Скобки — самые главные.*

---

### Пример из жизни: расчёт суммы заказа со скидкой

Допустим, ты пишешь код интернет-магазина.  
Покупатель положил в корзину 3 товара, каждый по 500₽, а скидка на заказ — 20%.

\`\`\`js
let quantity = 3;         // Количество товаров
let pricePerItem = 500;   // Цена за одну штуку
let discount = 0.2;       // Скидка (20%)

let total = quantity * pricePerItem - quantity * pricePerItem * discount;
console.log(total); // 1200
\`\`\`

**Пояснение:**

- \`quantity * pricePerItem = 3 * 500 = 1500\` — полная сумма без скидки
- \`1500 * discount = 1500 * 0.2 = 300\` — размер скидки
- \`1500 - 300 = 1200\` — итоговая сумма к оплате

---

### Как работает приоритет

JavaScript сначала выполняет умножение (\`*\`),  
Потом — вычитание (\`-\`).

Скобки можно использовать для наглядности. Это не обязательно, но повышает читаемость:

\`\`\`js
let total = (quantity * pricePerItem) - (quantity * pricePerItem * discount);
\`\`\`

---

### Пример с логическими операторами

\`\`\`js
let result = true || false && false;
console.log(result); // true
\`\`\`

**Почему?**  
\`&&\` (И) важнее, чем \`||\` (ИЛИ), значит:

- Сначала \`false && false → false\`
- Потом \`true || false → true\`

---

### Пример с присваиванием

\`\`\`js
let x = 5;
let y = 10;
let z = x = y;
console.log(z); // 10
\`\`\`

**Разбор:**

- Сначала \`x = y\` → \`x = 10\`
- Потом \`z = x\` → \`z = 10\`

Присваивание (\`=\`) — низкий приоритет, поэтому идёт последним.

---

### Как не запутаться?

- Скобки — твои друзья. Если не уверен в порядке — используй скобки.
- Всегда читай слева направо, если приоритеты одинаковые.

**Простой порядок запомнить:**

1. Скобки ()
2. Умножение / деление
3. Сложение / вычитание
4. Логика (&&, ||)
5. Присваивание =

  `,
  codeExampleJS: `
console.log(2 + 3 * 4); // 14

let quantity = 3;
let pricePerItem = 500;
let discount = 0.2;
let total = quantity * pricePerItem - quantity * pricePerItem * discount;
console.log(total); // 1200

let result = true || false && false;
console.log(result); // true

let x = 5;
let y = 10;
let z = x = y;
console.log(z); // 10
  `,
  resources: [
    "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence",
    "https://learn.javascript.ru/operators#prioritet-operatorov",
  ],
};
