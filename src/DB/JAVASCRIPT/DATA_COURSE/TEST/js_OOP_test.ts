export const js_OOP_test = {
  id: 518,
  name: "Основы ООП в JavaScript",
  category: "JavaScript",
  ques: [
    {
      id: 1,
      name: "Что такое инкапсуляция в ООП?",
      variants: [
        "Объединение данных и методов внутри объекта и скрытие внутренней логики",
        "Возможность наследовать свойства",
        "Способ вызова метода через new",
      ],
      correct: [0],
    },
    {
      id: 2,
      name: "Какое свойство класса обозначает приватное поле в JS?",
      variants: [
        "Символ # перед именем",
        "Символ _ перед именем",
        "Двоеточие перед именем",
      ],
      correct: [0],
    },
    {
      id: 3,
      name: "Что такое наследование?",
      variants: [
        "Создание нового класса на основе существующего",
        "Сокрытие внутренних свойств объекта",
        "Переопределение методов массива",
      ],
      correct: [0],
    },
    {
      id: 4,
      name: "Что такое полиморфизм?",
      variants: [
        "Возможность вызывать одинаковые методы у разных объектов с разным результатом",
        "Запрет на добавление новых методов",
        "Принудительная типизация",
      ],
      correct: [0],
    },
    {
      id: 5,
      name: "Что произойдёт при попытке обратиться к приватному полю (#password) вне класса?",
      variants: [
        "Будет ошибка",
        "Вернётся undefined",
        "Будет возвращено значение",
      ],
      correct: [0],
    },
    {
      id: 6,
      name: "Для чего нужен метод checkPassword в примере User?",
      variants: [
        "Для проверки приватного пароля",
        "Для изменения имени пользователя",
        "Для наследования",
      ],
      correct: [0],
    },
    {
      id: 7,
      name: "Что выведет dog.speak(), если Dog наследует Animal и переопределяет speak?",
      variants: [
        "Метод speak класса Dog",
        "Метод speak класса Animal",
        "Ошибка выполнения",
      ],
      correct: [0],
    },
    {
      id: 8,
      name: "Что означает вызов animal.speak() у объекта, созданного через Object.create(animal)?",
      variants: [
        "Вызывается метод прототипа animal",
        "Метод не найден, будет ошибка",
        "Вызывается глобальный метод",
      ],
      correct: [0],
    },
    {
      id: 9,
      name: "Что будет результатом вызова animals.forEach(animal => animal.speak()) если массив содержит Animal и Dog?",
      variants: [
        "Будут вызваны разные реализации speak для каждого объекта",
        "Будет вызван один и тот же метод",
        "Будет ошибка",
      ],
      correct: [0],
    },
    {
      id: 10,
      name: "Что делает Object.setPrototypeOf(obj, proto)?",
      variants: [
        "Устанавливает прототип для объекта",
        "Удаляет все свойства объекта",
        "Добавляет новое поле",
      ],
      correct: [0],
    },
    {
      id: 11,
      name: "Как узнать прототип объекта в JS?",
      variants: [
        "Object.getPrototypeOf(obj)",
        "obj.prototype",
        "obj.getPrototype()",
      ],
      correct: [0],
    },
    {
      id: 12,
      name: "Как создать объект с определённым прототипом?",
      variants: ["Object.create(proto)", "new proto()", "Object.assign(proto)"],
      correct: [0],
    },
    {
      id: 13,
      name: "Что возвращает метод toString() если его не переопределять?",
      variants: ["[object Object]", "undefined", "Тип объекта"],
      correct: [0],
    },
    {
      id: 14,
      name: "Почему не рекомендуется использовать __proto__?",
      variants: [
        "Это устаревший способ, есть Object.setPrototypeOf",
        "Он работает только в браузерах",
        "Он влияет на глобальный объект",
      ],
      correct: [0],
    },
    {
      id: 15,
      name: "Какая главная особенность JS — прототипное наследование?",
      variants: [
        "Объекты наследуют свойства и методы через цепочку прототипов",
        "Каждый объект наследует только от класса",
        "В JS нет наследования",
      ],
      correct: [0],
    },
    {
      id: 16,
      name: "Что такое функция-конструктор?",
      variants: [
        "Функция, вызываемая через new для создания объектов",
        "Обычная функция без this",
        "Метод класса",
      ],
      correct: [0],
    },
    {
      id: 17,
      name: "Что делает ключевое слово this внутри конструктора?",
      variants: [
        "Ссылается на создаваемый объект",
        "Ссылается на глобальный объект",
        "Указывает на прототип",
      ],
      correct: [0],
    },
    {
      id: 18,
      name: "Что такое свойство prototype у функции?",
      variants: [
        "Объект, куда добавляются методы и свойства, доступные всем экземплярам",
        "Копия конструктора",
        "Встроенный метод объекта",
      ],
      correct: [0],
    },
    {
      id: 19,
      name: "Как добавить метод всем объектам, созданным через конструктор User?",
      variants: [
        "User.prototype.methodName = function() {}",
        "User.methodName = function() {}",
        "User.constructor = function() {}",
      ],
      correct: [0],
    },
    {
      id: 20,
      name: "Что вернет выражение car1 instanceof Car если car1 создан через new Car?",
      variants: ["true", "false", "undefined"],
      correct: [0],
    },
    {
      id: 21,
      name: "Что такое класс в JavaScript?",
      variants: [
        "Синтаксический сахар над функцией-конструктором и прототипом",
        "Встроенный тип данных",
        "Массив объектов",
      ],
      correct: [0],
    },
    {
      id: 22,
      name: "Для чего используется extends при объявлении класса?",
      variants: [
        "Для наследования свойств и методов от другого класса",
        "Для создания приватных свойств",
        "Для объявления геттеров",
      ],
      correct: [0],
    },
    {
      id: 23,
      name: "Что делает super() в конструкторе дочернего класса?",
      variants: [
        "Вызывает конструктор родителя",
        "Создаёт новый экземпляр родителя",
        "Добавляет метод родителя в дочерний класс",
      ],
      correct: [0],
    },
    {
      id: 24,
      name: "Что будет, если не вызвать super() в конструкторе класса-наследника?",
      variants: [
        "Будет ошибка выполнения",
        "Методы родителя не унаследуются",
        "this станет undefined",
      ],
      correct: [0],
    },
    {
      id: 25,
      name: "Где обычно задаются свойства объекта в классе?",
      variants: ["В конструкторе", "В prototype", "В глобальном объекте"],
      correct: [0],
    },
    {
      id: 26,
      name: "Что такое геттер в классе?",
      variants: [
        "Метод для чтения (получения) значения свойства",
        "Метод для записи значения",
        "Приватное поле",
      ],
      correct: [0],
    },
    {
      id: 27,
      name: "Что такое сеттер в классе?",
      variants: [
        "Метод для задания значения свойства",
        "Метод для получения значения",
        "Метод для наследования",
      ],
      correct: [0],
    },
    {
      id: 28,
      name: "Как вызвать геттер в классе?",
      variants: [
        "Обратиться к свойству как к обычному: obj.prop",
        "Вызвать как функцию: obj.prop()",
        "Через ключевое слово get",
      ],
      correct: [0],
    },
    {
      id: 29,
      name: "Что позволяет делать сеттер в классе?",
      variants: [
        "Проверять и валидировать устанавливаемое значение",
        "Получать значение из внешней области",
        "Создавать статические свойства",
      ],
      correct: [0],
    },
    {
      id: 30,
      name: "Что произойдет при присваивании obj.name = 'Кот' если name — сеттер?",
      variants: [
        "Вызовется метод set name()",
        "Будет ошибка",
        "Перезапишется _name без проверки",
      ],
      correct: [0],
    },
  ],
};
