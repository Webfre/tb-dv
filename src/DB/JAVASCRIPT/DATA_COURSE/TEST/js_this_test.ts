export const js_this_test = {
  id: 517,
  name: "Контекст выполнения и this",
  category: "JavaScript",
  ques: [
    {
      id: 1,
      name: "Что такое контекст вызова (this) в JavaScript?",
      variants: [
        "Объект, к которому привязано ключевое слово this в момент вызова",
        "Переменная внутри функции",
        "Глобальная переменная",
      ],
      correct: [0],
    },
    {
      id: 2,
      name: "Когда определяется значение this в функции?",
      variants: [
        "В момент вызова функции",
        "При объявлении функции",
        "В момент компиляции",
      ],
      correct: [0],
    },
    {
      id: 3,
      name: "Какой будет результат user.show() в примере, если user = { name: 'Анна', show: showName }?",
      variants: ['"Анна"', "undefined", "Ошибка выполнения"],
      correct: [0],
    },
    {
      id: 4,
      name: "Если вызвать функцию вне объекта, на что указывает this?",
      variants: [
        "На глобальный объект (window в браузере)",
        "На undefined всегда",
        "На саму функцию",
      ],
      correct: [0],
    },
    {
      id: 5,
      name: "Что произойдет с this внутри вложенной функции, вызванной из метода объекта?",
      variants: [
        "this потеряется и будет undefined (или window)",
        "this останется как у внешнего метода",
        "this станет ссылаться на объект-родитель",
      ],
      correct: [0],
    },
    {
      id: 6,
      name: "Какое значение примет this при вызове обычной функции в нестрогом режиме?",
      variants: ["window (глобальный объект)", "undefined", "null"],
      correct: [0],
    },
    {
      id: 7,
      name: "Какое значение this будет внутри функции в строгом режиме ('use strict'), если вызвать её вне объекта?",
      variants: ["undefined", "window", "null"],
      correct: [0],
    },
    {
      id: 8,
      name: "Если функцию-метод объекта сохранить в отдельную переменную и вызвать, что произойдет?",
      variants: [
        "Потеря контекста: this станет undefined (или window)",
        "this останется прежним",
        "Вызов невозможен",
      ],
      correct: [0],
    },
    {
      id: 9,
      name: "Как НЕ терять контекст при передаче метода?",
      variants: [
        "Использовать .bind(), .call(), .apply()",
        "Вызвать метод только внутри объекта",
        "Заменить на обычную функцию",
      ],
      correct: [0],
    },
    {
      id: 10,
      name: "Что будет результатом вызова user.greet(), если user = { name: 'Ольга', greet() { console.log(this.name); } }?",
      variants: ['"Ольга"', "undefined", "Ошибка"],
      correct: [0],
    },
    {
      id: 11,
      name: "Если метод объекта вызван как user.method(), чему равен this?",
      variants: ["user", "window", "undefined"],
      correct: [0],
    },
    {
      id: 12,
      name: "Что произойдет с this при вызове вложенного метода: user.info.show()?",
      variants: [
        "this будет ссылаться на user.info",
        "this будет ссылаться на user",
        "this всегда window",
      ],
      correct: [0],
    },
    {
      id: 13,
      name: "Что произойдет, если передать user.sayHi как отдельную функцию?",
      variants: [
        "Потеряется контекст: this станет undefined (или window)",
        "Контекст останется прежним",
        "Будет ошибка синтаксиса",
      ],
      correct: [0],
    },
    {
      id: 14,
      name: "Что важно помнить о this в методах объекта?",
      variants: [
        "this зависит от способа вызова метода",
        "this всегда равен window",
        "this нельзя использовать в методах",
      ],
      correct: [0],
    },
    {
      id: 15,
      name: "Какой принцип this во вложенных объектах?",
      variants: [
        "this — тот объект, у которого вызван метод",
        "this всегда внешний объект",
        "this всегда null",
      ],
      correct: [0],
    },
    {
      id: 16,
      name: "Что делает .bind()?",
      variants: [
        "Возвращает новую функцию с жёстко привязанным this",
        "Мгновенно вызывает функцию с новым this",
        "Удаляет контекст у функции",
      ],
      correct: [0],
    },
    {
      id: 17,
      name: "Что произойдет при setTimeout(user.sayHi, 1000), если sayHi использует this?",
      variants: [
        "this потеряется, станет undefined (или window)",
        "sayHi вызовется немедленно",
        "this будет равен user",
      ],
      correct: [0],
    },
    {
      id: 18,
      name: "Как правильно не терять контекст при передаче метода в setTimeout?",
      variants: [
        "Использовать user.sayHi.bind(user)",
        "Передавать только ссылку на user",
        "Писать функцию без this",
      ],
      correct: [0],
    },
    {
      id: 19,
      name: "Что делает .bind(this) внутри класса?",
      variants: [
        "Привязывает this к экземпляру класса",
        "Удаляет функцию из класса",
        "Копирует метод",
      ],
      correct: [0],
    },
    {
      id: 20,
      name: "Что вернёт функция после применения .bind(user)?",
      variants: [
        "Новую функцию, где this всегда user",
        "Ту же функцию, без изменений",
        "Функцию с undefined вместо this",
      ],
      correct: [0],
    },
    {
      id: 21,
      name: "У стрелочных функций есть собственный this?",
      variants: [
        "Нет, берут this из внешнего контекста",
        "Да, всегда свой",
        "Только если явно указать",
      ],
      correct: [0],
    },
    {
      id: 22,
      name: "Где удобно использовать стрелочные функции с точки зрения контекста?",
      variants: [
        "В колбэках и методах массивов внутри объекта",
        "Только в глобальном коде",
        "Внутри setInterval всегда",
      ],
      correct: [0],
    },
    {
      id: 23,
      name: "Что произойдет, если внутри метода объекта объявить стрелочную функцию и вызвать её?",
      variants: [
        "Стрелочная функция возьмет this метода (объект)",
        "Стрелочная функция создаст свой this",
        "Будет ошибка",
      ],
      correct: [0],
    },
    {
      id: 24,
      name: "В чем ключевое отличие стрелочной функции от обычной в плане this?",
      variants: [
        "Стрелочная не имеет своего this",
        "Стрелочная всегда window",
        "Нет отличий",
      ],
      correct: [0],
    },
    {
      id: 25,
      name: "Какой результат вызова user.sayHi(), если внутри метода user объявлена стрелочная функция arrow, которая выводит this.name?",
      variants: [
        "this.name — это имя user",
        "this.name — undefined",
        "Ошибка выполнения",
      ],
      correct: [0],
    },
    {
      id: 26,
      name: "Что делает метод .call()?",
      variants: [
        "Вызывает функцию с заданным this и аргументами через запятую",
        "Привязывает функцию к объекту, не вызывая её",
        "Клонирует объект",
      ],
      correct: [0],
    },
    {
      id: 27,
      name: "Как отличаются call и apply?",
      variants: [
        "apply передает аргументы массивом, call — через запятую",
        "call только для методов, apply только для функций",
        "Нет различий",
      ],
      correct: [0],
    },
    {
      id: 28,
      name: "Что делает bind?",
      variants: [
        "Создаёт новую функцию с жёстко привязанным this",
        "Вызывает функцию немедленно",
        "Изменяет исходный объект",
      ],
      correct: [0],
    },
    {
      id: 29,
      name: "Что произойдет, если вызвать hi.call(person), где hi = person.sayHi?",
      variants: [
        "Контекст восстановится, this будет person",
        "Контекст потеряется, this — undefined",
        "Будет синтаксическая ошибка",
      ],
      correct: [0],
    },
    {
      id: 30,
      name: "Когда удобно использовать call/apply/bind?",
      variants: [
        "Для передачи нужного this вручную, если функция “оторвана” от объекта",
        "Только для методов массивов",
        "Только в setInterval",
      ],
      correct: [0],
    },
  ],
};
