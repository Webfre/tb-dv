export const js_async_test = {
  id: 512,
  name: "Асинхронность и промисы в JavaScript",
  category: "JavaScript",
  ques: [
    {
      id: 1,
      name: "Что такое асинхронный код?",
      variants: [
        "Код, который не блокирует выполнение других операций",
        "Код, который всегда выполняется последним",
        "Код, который работает только с числами",
      ],
      correct: [0],
    },
    {
      id: 2,
      name: "Что произойдет при выполнении кода:\nconsole.log('A');\nsetTimeout(()=>console.log('B'), 0);\nconsole.log('C');",
      variants: ["A, C, B", "A, B, C", "B, A, C"],
      correct: [0],
    },
    {
      id: 3,
      name: "В каких случаях обычно применяют асинхронность в JS?",
      variants: [
        "Сетевые запросы, таймеры, работа с файлами",
        "Математические вычисления",
        "Изменение CSS",
      ],
      correct: [0],
    },
    {
      id: 4,
      name: "Что делает Event Loop?",
      variants: [
        "Следит за стеком вызовов и запускает задачи из очереди, когда стек пуст",
        "Запускает все функции одновременно",
        "Сортирует массивы",
      ],
      correct: [0],
    },
    {
      id: 5,
      name: "Что такое Call Stack?",
      variants: [
        "Стек вызовов — структура для выполнения функций по принципу LIFO",
        "Очередь таймеров",
        "Список загруженных файлов",
      ],
      correct: [0],
    },
    {
      id: 6,
      name: "Где выполняются setTimeout и сетевые запросы?",
      variants: [
        "Во внешней среде (Web API браузера)",
        "Внутри Call Stack",
        "В памяти массива",
      ],
      correct: [0],
    },
    {
      id: 7,
      name: "Что делает setTimeout?",
      variants: [
        "Выполняет функцию один раз через заданное время",
        "Выполняет функцию бесконечно",
        "Останавливает выполнение кода",
      ],
      correct: [0],
    },
    {
      id: 8,
      name: "Что делает setInterval?",
      variants: [
        "Выполняет функцию периодически через равные промежутки времени",
        "Выполняет функцию только один раз",
        "Удаляет элементы массива",
      ],
      correct: [0],
    },
    {
      id: 9,
      name: "Как остановить выполнение setInterval?",
      variants: ["clearInterval(id)", "stopInterval()", "interval.clear()"],
      correct: [0],
    },
    {
      id: 10,
      name: "Что вернет setTimeout и setInterval?",
      variants: ["Идентификатор таймера (number)", "Промис", "Объект Date"],
      correct: [0],
    },
    {
      id: 11,
      name: "Что называют 'callback hell'?",
      variants: [
        "Глубокую вложенность колбэк-функций в асинхронном коде",
        "Ошибку в синтаксисе",
        "Случайное выполнение кода",
      ],
      correct: [0],
    },
    {
      id: 12,
      name: "Почему 'callback hell' считается плохой практикой?",
      variants: [
        "Плохо читается и сложно отлаживается",
        "Работает только в Node.js",
        "Быстро выполняется",
      ],
      correct: [0],
    },
    {
      id: 13,
      name: "Что позволяет избежать 'callback hell'?",
      variants: [
        "Промисы и async/await",
        "Больше вложенных функций",
        "document.write",
      ],
      correct: [0],
    },
    {
      id: 14,
      name: "В каком состоянии может находиться Promise?",
      variants: [
        "pending, fulfilled, rejected",
        "start, process, finish",
        "undefined, null, true",
      ],
      correct: [0],
    },
    {
      id: 15,
      name: "Что делает метод .then() у промиса?",
      variants: [
        "Обрабатывает успешный результат промиса",
        "Обрабатывает ошибку",
        "Останавливает выполнение промиса",
      ],
      correct: [0],
    },
    {
      id: 16,
      name: "Что делает .catch() у промиса?",
      variants: [
        "Обрабатывает ошибку (отклонение) промиса",
        "Запускает промис заново",
        "Форматирует дату",
      ],
      correct: [0],
    },
    {
      id: 17,
      name: "Для чего используется .finally()?",
      variants: [
        "Выполняется всегда после завершения промиса (успех или ошибка)",
        "Только при успешном завершении",
        "Только при ошибке",
      ],
      correct: [0],
    },
    {
      id: 18,
      name: "Что произойдет, если внутри .then() выбросить ошибку (throw)?",
      variants: [
        "Ошибка попадет в ближайший .catch()",
        "Промис зависнет навсегда",
        "Ничего не произойдет",
      ],
      correct: [0],
    },
    {
      id: 19,
      name: "Что делает Promise.all([p1, p2, p3])?",
      variants: [
        "Ждёт завершения всех промисов, возвращает массив результатов",
        "Возвращает только первый результат",
        "Отклоняется при любом выполнении",
      ],
      correct: [0],
    },
    {
      id: 20,
      name: "Что делает Promise.race([p1, p2, p3])?",
      variants: [
        "Возвращает результат первого завершившегося промиса (успех или ошибка)",
        "Ждёт только ошибки",
        "Отправляет промисы по очереди",
      ],
      correct: [0],
    },
    {
      id: 21,
      name: "Что делает ключевое слово async перед функцией?",
      variants: [
        "Делает функцию всегда возвращающей промис",
        "Делает функцию асинхронной и сразу выполняет её",
        "Добавляет задержку",
      ],
      correct: [0],
    },
    {
      id: 22,
      name: "Для чего используется await?",
      variants: [
        "Ожидает завершения промиса и возвращает его результат",
        "Запускает промис в параллели",
        "Ставит функцию в очередь",
      ],
      correct: [0],
    },
    {
      id: 23,
      name: "Где можно использовать await?",
      variants: [
        "Только внутри async-функции",
        "В любом месте программы",
        "Внутри обычного .then()",
      ],
      correct: [0],
    },
    {
      id: 24,
      name: "Что вернет async-функция, если внутри неё явно возвращено значение 5?",
      variants: ["Промис, который resolve(5)", "Число 5", "undefined"],
      correct: [0],
    },
    {
      id: 25,
      name: "Как обработать ошибку при использовании await?",
      variants: [
        "Обернуть в try...catch",
        "Использовать .error()",
        "await нельзя обрабатывать ошибки",
      ],
      correct: [0],
    },
    {
      id: 26,
      name: "Что произойдет, если промис, на который ссылается await, завершится с ошибкой вне try/catch?",
      variants: [
        "Будет выброшено исключение и ошибка появится в консоли",
        "Программа зависнет",
        "Ошибка проигнорируется",
      ],
      correct: [0],
    },
    {
      id: 27,
      name: "Как обработать несколько промисов параллельно с помощью async/await?",
      variants: [
        "await Promise.all([ ... ])",
        "await каждый промис по очереди",
        "await Promise.race([ ... ])",
      ],
      correct: [0],
    },
    {
      id: 28,
      name: "Что произойдет с Promise.all, если один из промисов завершится с ошибкой?",
      variants: [
        "Вся конструкция перейдет в состояние rejected, ошибка попадет в catch",
        "Promise.all проигнорирует ошибку",
        "Остальные промисы не выполнятся",
      ],
      correct: [0],
    },
    {
      id: 29,
      name: "Какая основная разница между промисами и async/await?",
      variants: [
        "async/await — синтаксический сахар над промисами, делает код последовательным и читаемым",
        "Промисы не поддерживают обработку ошибок",
        "async/await работает только с setTimeout",
      ],
      correct: [0],
    },
    {
      id: 30,
      name: "Что вернет следующий код?\nasync function f() { return 42; }\nf().then(console.log);",
      variants: ["42", "undefined", "Ошибка"],
      correct: [0],
    },
  ],
};
