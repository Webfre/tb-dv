export const js_errorHandling_test = {
  id: 513,
  name: "Обработка ошибок в JavaScript",
  category: "JavaScript",
  ques: [
    {
      id: 1,
      name: "Для чего используется конструкция try...catch?",
      variants: [
        "Для обработки ошибок во время выполнения кода",
        "Для объявления переменных",
        "Для форматирования дат",
      ],
      correct: [0],
    },
    {
      id: 2,
      name: "Что произойдет, если в блоке try возникнет ошибка?",
      variants: [
        "Выполнение перейдет в блок catch",
        "Код остановится и больше не выполнится",
        "Блок finally пропустится",
      ],
      correct: [0],
    },
    {
      id: 3,
      name: "Что находится в переменной catch(error)?",
      variants: [
        "Объект ошибки (Error) с подробностями",
        "Массив ошибок",
        "Имя файла с ошибкой",
      ],
      correct: [0],
    },
    {
      id: 4,
      name: "В каком случае catch не сработает?",
      variants: [
        "Если ошибка синтаксическая",
        "Если ошибка в try",
        "Если ошибка в JSON.parse",
      ],
      correct: [0],
    },
    {
      id: 5,
      name: "Что будет, если в try не возникнет ошибок?",
      variants: [
        "Блок catch пропустится",
        "Выполнится catch с пустым error",
        "Блок finally не сработает",
      ],
      correct: [0],
    },
    {
      id: 6,
      name: "Для чего нужен блок finally?",
      variants: [
        "Код в нем выполнится всегда — была ошибка или нет",
        "Выполняется только при ошибке",
        "Для объявления глобальных переменных",
      ],
      correct: [0],
    },
    {
      id: 7,
      name: "Что произойдет, если в finally возникнет ошибка?",
      variants: [
        "Ошибка в finally перекроет ошибку из try или catch",
        "Никакой ошибки не будет",
        "Ошибка из try все равно выведется",
      ],
      correct: [0],
    },
    {
      id: 8,
      name: "Выполнится ли finally, если в try есть return?",
      variants: [
        "Да, finally выполнится всегда",
        "Нет, finally пропустится",
        "Выполнится только если нет ошибок",
      ],
      correct: [0],
    },
    {
      id: 9,
      name: "Для чего используют оператор throw?",
      variants: [
        "Для явного выбрасывания ошибки",
        "Для объявления переменных",
        "Для завершения функции",
      ],
      correct: [0],
    },
    {
      id: 10,
      name: "Какой тип значения лучше использовать с throw?",
      variants: ["Объект Error или его подкласс", "Число", "Строку (всегда)"],
      correct: [0],
    },
    {
      id: 11,
      name: "Как прервать выполнение функции при ошибке в параметрах?",
      variants: [
        "Вызвать throw new Error()",
        "Использовать return без значения",
        "Вызвать alert",
      ],
      correct: [0],
    },
    {
      id: 12,
      name: "Что произойдет после throw?",
      variants: [
        "Выполнение сразу перейдет в ближайший catch",
        "Код продолжит выполняться дальше",
        "finally не выполнится",
      ],
      correct: [0],
    },
    {
      id: 13,
      name: "Какое свойство объекта Error содержит описание ошибки?",
      variants: ["message", "name", "stack"],
      correct: [0],
    },
    {
      id: 14,
      name: "Что хранит свойство stack у Error?",
      variants: [
        "Стек вызовов к моменту ошибки",
        "Вид ошибки",
        "Время возникновения ошибки",
      ],
      correct: [0],
    },
    {
      id: 15,
      name: "Как получить имя типа ошибки (например, TypeError)?",
      variants: ["error.name", "error.type", "error.desc"],
      correct: [0],
    },
    {
      id: 16,
      name: "Какие бывают встроенные типы ошибок?",
      variants: [
        "Error, TypeError, ReferenceError, SyntaxError, RangeError",
        "FunctionError, DataError",
        "ObjectError, NumberError",
      ],
      correct: [0],
    },
    {
      id: 17,
      name: "Можно ли создать свой подкласс ошибок?",
      variants: [
        "Да, расширив Error через class",
        "Нет, только встроенные",
        "Можно только с throw 'строкой'",
      ],
      correct: [0],
    },
    {
      id: 18,
      name: "В каком случае finally НЕ выполнится?",
      variants: [
        "Только при завершении работы процесса/вкладки браузера",
        "Если есть ошибка",
        "Если try пустой",
      ],
      correct: [0],
    },
    {
      id: 19,
      name: "Что произойдет, если в catch также возникнет ошибка?",
      variants: [
        "finally выполнится, а новая ошибка пойдет дальше",
        "finally пропустится",
        "Ошибка останется в catch",
      ],
      correct: [0],
    },
    {
      id: 20,
      name: "Где удобно применять try...catch?",
      variants: [
        "JSON.parse, работа с localStorage, сетевые запросы",
        "Везде, даже для циклов",
        "В объявлениях функций",
      ],
      correct: [0],
    },
    {
      id: 21,
      name: "Почему try...catch не ловит ошибки внутри setTimeout?",
      variants: [
        "Потому что ошибка возникает в другой (асинхронной) фазе",
        "Это баг в JavaScript",
        "setTimeout не может вызывать ошибки",
      ],
      correct: [0],
    },
    {
      id: 22,
      name: "Где правильно ловить ошибки, если используем промисы?",
      variants: [
        "В .catch() после цепочки .then()",
        "Внутри функции main()",
        "Через window.onerror",
      ],
      correct: [0],
    },
    {
      id: 23,
      name: "Как обработать ошибку при использовании await?",
      variants: [
        "Оборачивать в try...catch",
        "Вынести catch отдельно",
        "await ловит ошибку сам",
      ],
      correct: [0],
    },
    {
      id: 24,
      name: "Что произойдет, если не обернуть await в try...catch, а промис завершится с ошибкой?",
      variants: [
        "Ошибка будет не поймана и промис перейдет в состояние rejected",
        "Ошибка появится в блоке finally",
        "Код продолжит выполняться",
      ],
      correct: [0],
    },
    {
      id: 25,
      name: "Что можно использовать для глобальной обработки ошибок в промисах?",
      variants: ["window.onunhandledrejection", "alert", "setTimeout"],
      correct: [0],
    },
    {
      id: 26,
      name: "Как обработать ошибку внутри async-функции?",
      variants: [
        "Через try...catch внутри функции",
        "Только через .catch() снаружи",
        "async-функции не поддерживают обработку ошибок",
      ],
      correct: [0],
    },
    {
      id: 27,
      name: "Что будет, если в JSON.parse передать невалидную строку?",
      variants: [
        "Будет выброшена ошибка, её можно поймать через try...catch",
        "Метод просто вернет null",
        "Ошибка не возникнет",
      ],
      correct: [0],
    },
    {
      id: 28,
      name: "Можно ли выбрасывать ошибку с помощью throw в промисах?",
      variants: [
        "Да, throw внутри промиса автоматически вызывает reject",
        "Нет, throw не работает в промисах",
        "Можно только через return",
      ],
      correct: [0],
    },
    {
      id: 29,
      name: "Где хранится информация о том, где возникла ошибка?",
      variants: [
        "В свойстве stack объекта Error",
        "В error.location",
        "В error.cause",
      ],
      correct: [0],
    },
    {
      id: 30,
      name: "Что делает catch без параметров: catch {}?",
      variants: [
        "Ловит ошибку, но не предоставляет доступ к объекту ошибки",
        "Ничего не ловит",
        "Работает только с синтаксическими ошибками",
      ],
      correct: [0],
    },
  ],
};
